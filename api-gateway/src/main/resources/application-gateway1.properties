server.port=2001

# ----------------传统的路由配置方式----------------
#  单实例配置
# 路由规则配置 zuul.routes.路由名字.key=value 的形式配置
# key 包含两个 一个 path 一个url
# path 表示路由路径
# url 表示匹配到的路由转到的地址
#例如：http://localhost:2001/api-a-url/hello 地址将被转到  http://localhost:8001/hello
zuul.routes.api-a-url.path=/api-a-url/**
zuul.routes.api-a-url.url=http://localhost:8001/

# path 路径中的通配符讲解
# /api-a-url/？   匹配任意单个字符
# /api-a-url/*    匹配任意数量字符
# /api-a-url/**   匹配任意数量字符，并支持多级目录



# 多实例配置
# serviceId 是手工命令的服务名称，配合 ribbon.listOfServers 参数实现服务与实例的维护
# 因为 serviceId 不是 eureka的，所以这里需要把eureka禁用
#zuul.routes.api-aa-url.path=/api-aa-url/**
#zuul.routes.api-aa-url.serviceId=api-aa-url
#ribbon.eureka.enabled=false
#api-aa-url.ribbon.listOfServers=http://localhost:8001/,localhost:8002/


# -----------面向服务的路由配置方式---------------
# 路由规则配置 zuul.routes.路由名字.key=value 的形式配置
# key 包含两个 一个 path 一个serviceId
# path 表示路由路径
# serviceId 表示匹配到的路由服务ID
#zuul.routes.api-a.path=/api-a/**
#zuul.routes.api-a.serviceId=hello-service
#zuul.routes.api-b.path=/api-b/**
#zuul.routes.api-b.serviceId=feign-consumer

#这是一种面向服务路由配置的简洁方式
# zuul.routes.<serviceId>=<path>
zuul.routes.hello-service=/api-a/**





# 由于我们使用了 zuul + eureka,默认情况下所有的Eureka上的服务都会被zuul自动的创建映射关系来路由，
# 默认情况下 path 会使用 serviceId 作为前缀，格式：zuul.routes.<serviceId>=/<serviceId>/**
# 这使得我们不希望对外开放的服务也能被外部访问到了，这个时候我们就需要 zuul.ignored-services 参数了
# 设置一个服务名匹配表达式，用来定义不自动创建路由的规则,
# 设定了zuul.ignored-service=* 的时候就需要我们一个个手动创建路由规则
#zuul.ignored-services=*

# 忽略表达式参数，该参数用来设置不希望被API网关进行路由的URL表达式
# 例如，我们不希望 hello 接口被路由，可以如下设置
#zuul.ignored-patterns=/**/hello/**


# 请求连接的超时时间
ribbon.ConnectTimeout=5000
#  请求处理的超时时间
ribbon.ReadTimeout=5000



#注册中心地址
eureka.client.serviceUrl.defaultZone=http://peer1:9001/eureka/,http://peer2:9002/eureka/
#服务实例元数据，设置实例名，区分同一服务中不同实例的唯一标识
eureka.instance.instance-id=${spring.cloud.client.ip-address}:${server.port}
#启用注册IP
eureka.instance.prefer-ip-address=true

# 设置全局日记级别
#logging.level.root=debug
